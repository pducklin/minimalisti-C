/* guardstk.S */

#ifndef __x86_64__
#   error Target is not X86_64
#endif

.global tinyc_canary            // the process-specific canary value itself
.global tinyc_canary_init       // call this at startup (from crt1.c and friends)
.global tinyc_canary_chk        // invoked at the end of every canaried function

/*----------*/

.data
.align 8
tinyc_canary:     .quad  0xE57ADE3ABE2ED3ED
tinyc_canary_set: .int   0

/*----------*/

.text

// possibly useful instructions for pseudo-random data and "bit-mixing"
// if EFLAGS has bit 21 set, then CPUID exists
// do CPUID(EAX=1),       if EDX has bit  4 (0x00000010) set then RDTSC exists
//                        if ECX has bit 20 (0x00100000) set then CRC32 exists (part of SSE4.2)
//                        if ECX has bit 30 (0x40000000) set then RDRAND exists
// do CPUID(EAX=7,ECX=0), if EBX has bit 18 (0x00040000) set then RDSEED exists
// and we always have RIP, which has some entropy if ASLR is used, plus the PEB address
//
// CRC32 takes src and folds it into the value in dst using CRC32 
// RDRAND puts 64 bits into 64-bit register
// RDSEED puts 64 bits into 64-bit register
// RDTSC puts 64 bits into EDX:EAX (bottom 32 bits wrap in 4Gcycles, highest bits tend to be 0)
// RIP is 64 bits but for non-HIGH_ENTROPY_VA EXE programs, only about 8 bits will vary
// PEB pointers are generated by Windows with unknown variability and entropy
//
// CPUID                  == 0f a2
// CRC32  %EAX into %ECX  == f2 0f 38 f1 c8
// RDRAND %RAX            == 48 0f c7 f0
// RDSEED %RAX            == 48 0f c7 f8
//
// Here, I have settled on using RDRAND on its own if it's available, or else
// on stirring together RIP, the PEB pointer, the default canary value (chosen
// randomly), and the output of RDTSC if it's available. The low byte of the 
// canary is always set to zero to prevent a known style of attack where an
// unterminated string hard up to the canary (which is not technically a buffer
// overflow) gets printed out and thereby leaks the canary for later abuse.
// Using CRC32 would make the canaries look "more random" and shield any 
// patterns caused by related addresses being mixed together, but seems to be
// a needless complexity given that it doesn't change the *unpredictability*.
// Unlike the Windows canary setup, I wanted this to use no API calls at all,
// so I can call it for every EXE or DLL, even UEFI apps, without triggering
// any load-time dependencies. The canary will be there, whether used or not,
// if the PETCC64 stdlib is used (or guardstack.o is otherwise linked in).


tinyc_rand64:   
    mov   $1, %eax
   .byte  0x0F,0xA2                  // CPUID

    // use RDRAND by itself, if available

    test  $0x40000000, %ecx
    jz    tr_tryrdtsc
tr_dorand: 
   .byte 0x48,0x0F,0xC7,0xF0         // RDRAND RAX
    jnc   tr_dorand                  // loop until it works
    jmp   tr_done
  
    // if no RDRAND, use RDTSC (if available), RIP and PEB 

tr_tryrdtsc:                         // see if RDTSC is available
    test  $0x00000010, %edx
    jnz   tr_dotsc
tr_0:                                // if not start with the default canary
    mov   tinyc_canary-tr_0-4(%rip), %rax 
    jmp   tr_getmore

tr_dotsc:    
    rdtsc                            // if RDTSC is there to help 
    shl   $32,  %rax                 // put EAX in the top 32 bits
    rol   $8, %edx                   // bottom 8 bits will otherwise be wasted later
    xor   %rdx, %rax                 // put EDX in the low 32 (less entropy here)
tr_1:                                // and fold in the default canary too
    xor   tinyc_canary-tr_1-4(%rip), %rax 
      
tr_getmore:
    lea   -3(%rip), %rdx             // get ASLRed RIP to mix in 
    rol   $15, %rdx                  // move most useful bits up a bit
    xor   %rdx, %rax                 // (only about 8 bits of entropy here)
    mov   %gs:(0x60), %rdx           // get PEB pointer
    rol   $9, %rdx                   // rotate to de-align any addr patterns
    xor   %rdx, %rax                 // mix in the tweaked PEB address

tr_done:
    mov   $0, %al                    // force a string-ending NUL into low byte
    ret                              // so there's a blocker byte after locals

// -----

tinyc_canary_init:
tci1:                                // see if we've already done this
    cmpl  $0, tinyc_canary_set-tci1-4(%rip)
    jne   tci_done                   // avoid changing the canary mid-program!
tci_try:    
    call  tinyc_rand64               // get a random value
tci2:    
    cmpq  %rax, tinyc_canary-tci2-4(%rip)
    je    tci_try                    // make sure it's not just the default 
tci3:    
    movq  %rax, tinyc_canary-tci3-4(%rip)
tci4:                                // and mark that we've done the setup
    incl  tinyc_canary_set-tci4-4(%rip)
tci_done:    
    ret

// -----    

tinyc_canary_chk:
    movq  %rsp, %rcx
    add   $8, %rcx                   // correct for return addr of this func
    xor   -8(%rbp), %rcx             // unmix the on-stack canary copy
tcc1:    
    cmpq  %rcx, tinyc_canary-tcc1-4(%rip)
    jne   tcc_fastfail               // if it doesn't match the original...
    ret
tcc_fastfail:                        // ...use Microsoft's fastfail system
    mov   $2, %ecx                   // code 2 means a  stack-check error
    int   $0x29                      // bail without trusting further API calls

